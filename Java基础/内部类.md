# 内部类

##分类：

1. 成员内部类
2. 成员内部类（包含匿名内部类）  
  
###成员内部类的定义格式：  

```java
修饰符 class 外部类名称｛
	修饰符 class 内部类名称｛
        ｝
   ｝ 
```


**注意：**内用外，随意访问；外用内，需要内部类对象。  

####如何使用成员内部类？有两种方式：

1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法
2. 直接方式，公式：  
*类名称 对象名 = new 类名称（）；*  
【外部内名称.内部类名称 对象名 = new 外部类名称（）.new 内部类名称（）；】  
  
####内部类的同名变量访问  

*如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名*  

如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。  
“局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。  
定义格式：  

```java
修饰符 class 外部类名称｛  
    修饰符 返回值类型 外部类方法名称（参数列表）｛  
        class 局部内部类名称｛  
//方法体
		｝

	｝

｝
```

 

小结一下类的权限修饰符：  
*public > protected > (default) > private*   
**定义一个类的时候，权限修饰符规则：**  
1. 外部类：public / (default)
2. 成员内部类：public / protected / (default) / private
3. 局部内部类：什么都不能写  
  
**局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】**  
备注：从Java 8+开始，只要局部变量不变，那么final关键字可以省略。  
原因：  
1. new出来的对象在堆内存当中
2. 局部变量是跟着方法走的，在栈内存当中
3. 方法运行结束之后，立刻出栈，局部变量立刻消失
4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。  
  
**匿名内部类**  
如果接口的实现类（或者是父类的子类）只使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改名为使用【匿名内部类】  

匿名类部类的定义格式：  
==接口名称 对象名 = new 接口名称（） ｛
//覆盖重写所有抽象方法｝**；**==  

对格式“new 接口名称（）｛...｝”进行解析：
1. new代表创建对象的动作
2. 接口名称就是匿名内部类需要实现哪个接口
3. ｛...｝这才是匿名内部类的内容  
  
另外还要注意几点问题：
1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。如果希望多次创建对象，而且类的内容一样的话，那么久必须使用单独定义的实现类了。
2. 匿名对象，在【调用方法】的时候，只能调用唯一一次，如果希望同一个对象，调用多次方法，那么必须给对象起个名字
3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象时省略了【对象名称】**强调：匿名内部类和匿名对象不是一回事！！！**  
  
比如：
```
接口名称 对象名 = new 接口名称（）｛方法体名称｝；
对象名.方法体名称//这样写的用法是对的
 new 接口名称（）｛方法体名称｝.方法体名称；  // 这样写的用法也是对的（这是用匿名对象进行匿名内部类的实现） 
```
**类作为成员变量的类型**

**接口作为成员变量的类型**

**接口作为方法的参数和返回值**